// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package database

import (
	"context"
	"time"
)

const createNormalUser = `-- name: CreateNormalUser :exec
INSERT INTO users (
        role_id,
        first_name,
        last_name,
        email,
        password,
        subscription_id
    )
VALUES (2, ?, ?, ?, ?, 2)
`

type CreateNormalUserParams struct {
	FirstName string
	LastName  string
	Email     string
	Password  string
}

func (q *Queries) CreateNormalUser(ctx context.Context, arg CreateNormalUserParams) error {
	_, err := q.db.ExecContext(ctx, createNormalUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
	)
	return err
}

const createSuperUser = `-- name: CreateSuperUser :exec
INSERT INTO users (
        role_id,
        first_name,
        last_name,
        email,
        password,
        subscription_id
    )
VALUES (1, ?, ?, ?, ?, 1)
`

type CreateSuperUserParams struct {
	FirstName string
	LastName  string
	Email     string
	Password  string
}

func (q *Queries) CreateSuperUser(ctx context.Context, arg CreateSuperUserParams) error {
	_, err := q.db.ExecContext(ctx, createSuperUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
	)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE FROM users
WHERE user_id = ?
`

func (q *Queries) DeleteUserByID(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserByID, userID)
	return err
}

const getAllUsersPaginated = `-- name: GetAllUsersPaginated :many
SELECT users.user_id,
    roles.name AS 'role',
    users.first_name,
    users.last_name,
    users.email,
    users.password,
    users.verify,
    subscriptions.status AS 'subscription status',
    users.created_at,
    users.updated_at
FROM users
    JOIN roles USING(role_id)
    JOIN subscriptions USING (subscription_id)
ORDER BY users.created_at DESC
LIMIT ? OFFSET ?
`

type GetAllUsersPaginatedParams struct {
	Limit  int32
	Offset int32
}

type GetAllUsersPaginatedRow struct {
	UserID             int32
	Role               RolesName
	FirstName          string
	LastName           string
	Email              string
	Password           string
	Verify             bool
	SubscriptionStatus SubscriptionsStatus
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

func (q *Queries) GetAllUsersPaginated(ctx context.Context, arg GetAllUsersPaginatedParams) ([]GetAllUsersPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersPaginatedRow
	for rows.Next() {
		var i GetAllUsersPaginatedRow
		if err := rows.Scan(
			&i.UserID,
			&i.Role,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Password,
			&i.Verify,
			&i.SubscriptionStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT users.user_id,
    roles.name AS 'role',
    users.first_name,
    users.last_name,
    users.email,
    users.password,
    subscriptions.status AS 'subscription status',
    users.verify,
    users.created_at,
    users.updated_at
FROM users users
    JOIN roles roles USING(role_id)
    JOIN subscriptions subscriptions USING (subscription_id)
WHERE email = ?
`

type GetUserByEmailRow struct {
	UserID             int32
	Role               RolesName
	FirstName          string
	LastName           string
	Email              string
	Password           string
	SubscriptionStatus SubscriptionsStatus
	Verify             bool
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.SubscriptionStatus,
		&i.Verify,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT users.user_id,
    roles.name AS 'role',
    users.first_name,
    users.last_name,
    users.email,
    users.password,
    users.verify,
    subscriptions.status AS 'subscription status',
    users.created_at,
    users.updated_at
FROM users users
    JOIN roles roles USING(role_id)
    JOIN subscriptions subscriptions USING (subscription_id)
WHERE user_id = ?
`

type GetUserByIDRow struct {
	UserID             int32
	Role               RolesName
	FirstName          string
	LastName           string
	Email              string
	Password           string
	Verify             bool
	SubscriptionStatus SubscriptionsStatus
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

func (q *Queries) GetUserByID(ctx context.Context, userID int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.UserID,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.Verify,
		&i.SubscriptionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoleByUserID = `-- name: GetUserRoleByUserID :one
SELECT roles.name
FROM users users
    JOIN roles roles using(role_id)
WHERE user_id = ?
`

func (q *Queries) GetUserRoleByUserID(ctx context.Context, userID int32) (RolesName, error) {
	row := q.db.QueryRowContext(ctx, getUserRoleByUserID, userID)
	var name RolesName
	err := row.Scan(&name)
	return name, err
}

const updateUserInformation = `-- name: UpdateUserInformation :exec
UPDATE users
SET first_name = ?,
    last_name = ?,
    email = ?
WHERE user_id = ?
`

type UpdateUserInformationParams struct {
	FirstName string
	LastName  string
	Email     string
	UserID    int32
}

func (q *Queries) UpdateUserInformation(ctx context.Context, arg UpdateUserInformationParams) error {
	_, err := q.db.ExecContext(ctx, updateUserInformation,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.UserID,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password = ?
WHERE user_id = ?
`

type UpdateUserPasswordParams struct {
	Password string
	UserID   int32
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.Password, arg.UserID)
	return err
}

const updateUserSubscriptionStatus = `-- name: UpdateUserSubscriptionStatus :exec
UPDATE users
SET subscription_id = ?
WHERE user_id = ?
`

type UpdateUserSubscriptionStatusParams struct {
	SubscriptionID int8
	UserID         int32
}

func (q *Queries) UpdateUserSubscriptionStatus(ctx context.Context, arg UpdateUserSubscriptionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSubscriptionStatus, arg.SubscriptionID, arg.UserID)
	return err
}

const updateUserToNormalUser = `-- name: UpdateUserToNormalUser :exec
UPDATE users
SET role_id = 2
WHERE user_id = ?
`

func (q *Queries) UpdateUserToNormalUser(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, updateUserToNormalUser, userID)
	return err
}

const updateUserToSuperUser = `-- name: UpdateUserToSuperUser :exec
UPDATE users
SET role_id = 1
WHERE user_id = ?
`

func (q *Queries) UpdateUserToSuperUser(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, updateUserToSuperUser, userID)
	return err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :exec
UPDATE users
SET verify = ?
WHERE user_id = ?
`

type UpdateUserVerificationStatusParams struct {
	Verify bool
	UserID int32
}

func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserVerificationStatus, arg.Verify, arg.UserID)
	return err
}
