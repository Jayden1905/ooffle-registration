// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package database

import (
	"context"
	"time"
)

const createNormalUser = `-- name: CreateNormalUser :exec
INSERT INTO users (role_id, first_name, last_name, email, password, subscription_id)
VALUES (2,?, ?, ?, ?, 2)
`

type CreateNormalUserParams struct {
	FirstName string
	LastName  string
	Email     string
	Password  string
}

func (q *Queries) CreateNormalUser(ctx context.Context, arg CreateNormalUserParams) error {
	_, err := q.db.ExecContext(ctx, createNormalUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
	)
	return err
}

const createSuperUser = `-- name: CreateSuperUser :exec
INSERT INTO users (role_id, first_name, last_name, email, password, subscription_id)
VALUES (1,?, ?, ?, ?, 1)
`

type CreateSuperUserParams struct {
	FirstName string
	LastName  string
	Email     string
	Password  string
}

func (q *Queries) CreateSuperUser(ctx context.Context, arg CreateSuperUserParams) error {
	_, err := q.db.ExecContext(ctx, createSuperUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
	)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
	users.user_id,
    roles.name AS 'role',
    users.first_name,
    users.last_name,
    users.email,
    users.password,
    subscriptions.status AS 'subscription status',
    users.created_at,
    users.updated_at
FROM users users
JOIN roles roles USING(role_id)
JOIN subscriptions subscriptions USING (subscription_id)
WHERE email = ?
`

type GetUserByEmailRow struct {
	UserID             int32
	Role               RolesName
	FirstName          string
	LastName           string
	Email              string
	Password           string
	SubscriptionStatus SubscriptionsStatus
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.SubscriptionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
	users.user_id,
    roles.name AS 'role',
    users.first_name,
    users.last_name,
    users.email,
    users.password,
    subscriptions.status AS 'subscription status',
    users.created_at,
    users.updated_at
FROM users users
JOIN roles roles USING(role_id)
JOIN subscriptions subscriptions USING (subscription_id)
WHERE user_id = ?
`

type GetUserByIDRow struct {
	UserID             int32
	Role               RolesName
	FirstName          string
	LastName           string
	Email              string
	Password           string
	SubscriptionStatus SubscriptionsStatus
	CreatedAt          time.Time
	UpdatedAt          time.Time
}

func (q *Queries) GetUserByID(ctx context.Context, userID int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.UserID,
		&i.Role,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.SubscriptionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoleByUserID = `-- name: GetUserRoleByUserID :one
SELECT roles.name
FROM users users
JOIN roles roles using(role_id)
WHERE user_id = ?
`

func (q *Queries) GetUserRoleByUserID(ctx context.Context, userID int32) (RolesName, error) {
	row := q.db.QueryRowContext(ctx, getUserRoleByUserID, userID)
	var name RolesName
	err := row.Scan(&name)
	return name, err
}

const updateUserToNormalUser = `-- name: UpdateUserToNormalUser :exec
UPDATE users SET role_id = 2 WHERE user_id = ?
`

func (q *Queries) UpdateUserToNormalUser(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, updateUserToNormalUser, userID)
	return err
}

const updateUserToSuperUser = `-- name: UpdateUserToSuperUser :exec
UPDATE users SET role_id = 1 WHERE user_id = ?
`

func (q *Queries) UpdateUserToSuperUser(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, updateUserToSuperUser, userID)
	return err
}
